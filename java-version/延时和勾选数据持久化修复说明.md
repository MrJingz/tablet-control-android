# 延时和勾选数据持久化修复说明

## 🎯 问题描述

**问题现象**：
- 延时和勾选数据没有保存在 `project_data.json` 文件中
- 从主页面进入编辑界面重新打开会话框时，延时状态为初始状态
- 勾选框也是初始状态，无法恢复之前的配置

**根本原因**：
1. **指令延时字段缺失**：保存指令数据时只保存了5个基本字段，缺少延时字段
2. **实例组配置数据缺失**：实例组的指令列表和延时设置没有保存到JSON文件
3. **数据加载不完整**：加载时没有正确恢复延时和实例组配置数据

---

## 🔧 修复方案

### 1. 修复指令数据保存 - 添加延时字段

#### 修复前（saveInstanceData方法）：
```java
// 只保存5个基本字段，缺少延时
JsonObject commandObj = new JsonObject();
commandObj.addProperty("name", parts[0]);
commandObj.addProperty("protocol", parts[1]);
commandObj.addProperty("ip", parts[2]);
commandObj.addProperty("port", parts[3]);
commandObj.addProperty("command", parts[4]);
```

#### 修复后：
```java
// 保存完整的6个字段，包含延时
JsonObject commandObj = new JsonObject();
commandObj.addProperty("name", parts[0]);
commandObj.addProperty("protocol", parts[1]);
commandObj.addProperty("ip", parts[2]);
commandObj.addProperty("port", parts[3]);
commandObj.addProperty("command", parts[4]);
// 保存延时字段
if (parts.length >= 6) {
    commandObj.addProperty("delay", parts[5]);
} else {
    commandObj.addProperty("delay", "0");
}
```

### 2. 添加实例组配置数据保存

#### 实例组指令列表保存：
```java
// 保存实例组指令列表
Object instanceGroupCommands = instance.getClientProperty("instanceGroupCommands");
if (instanceGroupCommands instanceof java.util.List) {
    com.google.gson.JsonArray groupCommandsArray = new com.google.gson.JsonArray();
    @SuppressWarnings("unchecked")
    java.util.List<String> groupCommandList = (java.util.List<String>) instanceGroupCommands;
    for (String cmd : groupCommandList) {
        groupCommandsArray.add(cmd);
    }
    instanceData.add("instanceGroupCommands", groupCommandsArray);
    System.out.println("保存实例组指令列表，共 " + groupCommandList.size() + " 条指令");
}
```

#### 实例组延时设置保存：
```java
// 保存实例组延时设置
Object instanceGroupDelays = instance.getClientProperty("instanceGroupDelays");
if (instanceGroupDelays instanceof java.util.Map) {
    JsonObject delaysObj = new JsonObject();
    @SuppressWarnings("unchecked")
    java.util.Map<String, String> delayMap = (java.util.Map<String, String>) instanceGroupDelays;
    for (java.util.Map.Entry<String, String> entry : delayMap.entrySet()) {
        delaysObj.addProperty(entry.getKey(), entry.getValue());
    }
    instanceData.add("instanceGroupDelays", delaysObj);
    System.out.println("保存实例组延时设置，共 " + delayMap.size() + " 条延时");
}
```

### 3. 修复数据加载 - 恢复延时字段

#### 修复前（loadInstanceFromData方法）：
```java
// 只加载5个基本字段，缺少延时
String commandData = String.format("%s|%s|%s|%s|%s", name, protocol, ip, port, command);
```

#### 修复后：
```java
// 加载完整的6个字段，包含延时
String delay = commandObj.has("delay") ? commandObj.get("delay").getAsString() : "0";
String commandData = String.format("%s|%s|%s|%s|%s|%s", name, protocol, ip, port, command, delay);
System.out.println("加载指令: " + name + ", 延时: " + delay + "秒");
```

### 4. 添加实例组配置数据加载

#### 实例组指令列表加载：
```java
// 加载实例组指令列表
if (instanceData.has("instanceGroupCommands")) {
    com.google.gson.JsonArray groupCommandsArray = instanceData.getAsJsonArray("instanceGroupCommands");
    java.util.List<String> groupCommands = new java.util.ArrayList<>();
    for (int i = 0; i < groupCommandsArray.size(); i++) {
        String cmd = groupCommandsArray.get(i).getAsString();
        groupCommands.add(cmd);
    }
    instance.putClientProperty("instanceGroupCommands", groupCommands);
    System.out.println("加载实例组指令列表，共 " + groupCommands.size() + " 条指令");
}
```

#### 实例组延时设置加载：
```java
// 加载实例组延时设置
if (instanceData.has("instanceGroupDelays")) {
    JsonObject delaysObj = instanceData.getAsJsonObject("instanceGroupDelays");
    java.util.Map<String, String> delayMap = new java.util.HashMap<>();
    for (String key : delaysObj.keySet()) {
        String value = delaysObj.get(key).getAsString();
        delayMap.put(key, value);
    }
    instance.putClientProperty("instanceGroupDelays", delayMap);
    System.out.println("加载实例组延时设置，共 " + delayMap.size() + " 条延时");
}
```

---

## 📊 JSON数据结构变化

### 修复前的JSON结构：
```json
{
  "pageContents": {
    "页面1": [
      {
        "commands": [
          {
            "name": "指令1",
            "protocol": "TCP",
            "ip": "192.168.1.100",
            "port": "8080",
            "command": "01 02 03"
            // 缺少 delay 字段
          }
        ],
        "instanceGroupName": "实例组1"
        // 缺少 instanceGroupCommands 和 instanceGroupDelays
      }
    ]
  }
}
```

### 修复后的JSON结构：
```json
{
  "pageContents": {
    "页面1": [
      {
        "commands": [
          {
            "name": "指令1",
            "protocol": "TCP",
            "ip": "192.168.1.100",
            "port": "8080",
            "command": "01 02 03",
            "delay": "2.5"
          }
        ],
        "instanceGroupName": "实例组1",
        "instanceGroupCommands": [
          "指令1|TCP|192.168.1.100|8080|01 02 03|2.5",
          "指令2|UDP|192.168.1.101|9090|04 05 06|1.0"
        ],
        "instanceGroupDelays": {
          "指令1": "2.5",
          "指令2": "1.0"
        }
      }
    ]
  }
}
```

---

## ✅ 修复效果

### 数据持久化完整性
- ✅ **指令延时保存**：所有指令的延时设置都保存到JSON文件
- ✅ **实例组配置保存**：实例组的指令列表和延时设置完整保存
- ✅ **向后兼容**：支持旧格式数据的加载和转换
- ✅ **数据完整性**：确保所有配置数据都能正确持久化

### 状态恢复功能
- ✅ **延时状态恢复**：重新打开界面时，延时设置正确恢复
- ✅ **勾选状态恢复**：实例组配置的勾选状态正确恢复
- ✅ **独立数据管理**：指令列表管理和实例组配置的延时设置独立存储
- ✅ **实时同步**：配置变化立即保存到文件

### 调试支持
- ✅ **详细日志**：保存和加载过程都有详细的调试输出
- ✅ **数据验证**：可以清楚看到保存和恢复的数据内容
- ✅ **问题定位**：便于快速发现和解决数据持久化问题

---

## 🎯 使用验证

### 测试延时数据持久化
1. 在指令列表管理中设置指令延时
2. 点击"保存"按钮保存项目数据
3. 重启应用程序或切换到主页面再回到编辑界面
4. 重新打开指令列表管理，验证延时设置是否保持

### 测试实例组配置持久化
1. 配置实例组，选择指令并设置延时
2. 点击"确定"保存实例组配置
3. 点击"保存"按钮保存项目数据
4. 重启应用程序或切换到主页面再回到编辑界面
5. 重新打开实例组配置，验证勾选状态和延时设置是否保持

### 验证JSON文件内容
1. 配置完成后，查看 `USERDATA/project_data.json` 文件
2. 确认文件中包含 `delay` 字段、`instanceGroupCommands` 和 `instanceGroupDelays` 字段
3. 验证数据格式正确，内容完整

---

## 🎉 总结

### 主要成就
1. **完整的数据持久化**：所有延时和勾选配置都能正确保存和恢复
2. **独立的数据管理**：指令列表管理和实例组配置使用独立的存储机制
3. **向后兼容性**：支持旧格式数据的加载和自动转换
4. **完善的调试支持**：详细的日志输出便于问题排查

### 技术亮点
- **扩展的JSON结构**：增加了延时和实例组配置字段
- **智能数据转换**：自动处理新旧格式的数据转换
- **完整的生命周期**：从保存到加载的完整数据流程
- **独立存储机制**：避免不同模块间的数据干扰

### 用户价值
- **配置持久化**：用户的所有配置都能可靠保存
- **状态恢复**：重新打开界面时配置状态完整恢复
- **数据安全**：不会因为程序重启而丢失配置
- **使用便捷**：无需重复配置，提升工作效率

现在的系统具有：
- ✅ **完整的数据持久化机制**：所有配置都能正确保存到JSON文件
- ✅ **可靠的状态恢复功能**：重新打开界面时状态完整恢复
- ✅ **独立的数据管理**：不同模块的配置互不干扰
- ✅ **完善的向后兼容性**：支持旧数据格式的自动转换

这个修复确保了用户配置的完整性和持久性！🚀
